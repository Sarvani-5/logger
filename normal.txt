ListView:
adapter : ArrayAdapter<String>
adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, ArrayList<String>())
 eventsListView.adapter = adapter
 adapter.add("${event.id} - ${event.name} - ${event.location}")

Table view:
 val tableRow = TableRow(this)
 val tvDescription = TextView(this)
tableRow.addView(tvDescription)
 tableLayout.addView(tableRow)


Explicit Intent:
val intent = Intent(this, ContactActivity::class.java)
                startActivity(intent)

Menu:
<menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:app="http://schemas.android.com/apk/res-auto">
Options menu:

override fun onCreateOptionsMenu(menu: Menu?): Boolean {
        menuInflater.inflate(R.menu.options_menu, menu)
        return true
    }
 override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when(item.itemId){
            R.id.profile -> {
                val intent = Intent(this, ProfileActivity::class.java)
                startActivity(intent)
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }

PopupMenu:
contact_btn.setOnClickListener { view ->
            showPopup(view)
        }
private fun showPopup(view: View) {
        val popup = PopupMenu(this, view)
        popup.menuInflater.inflate(R.menu.popup_menu, popup.menu)
        popup.setOnMenuItemClickListener { item ->
            when(item.itemId) {
                R.id.sms -> {
                    sendSMS()
                    true
                }
                else -> false
            }
        }
        popup.show()
    }

Context Menu:
registerForContextMenu(rate_btn)
override fun onCreateContextMenu(
        menu: ContextMenu?,
        v: View?,
        menuInfo: ContextMenu.ContextMenuInfo?
    ) {
        super.onCreateContextMenu(menu, v, menuInfo)
        menuInflater.inflate(R.menu.context_menu, menu)
    }

    override fun onContextItemSelected(item: MenuItem): Boolean {
        return when(item.itemId) {
            R.id.r4 -> {
                Toast.makeText(this, "Thanks for giving 4 stars", Toast.LENGTH_SHORT).show()
                true
            }
            else -> super.onContextItemSelected(item)
        }
    }

SharedPreferences:

val sharedPref = getSharedPreferences("userPrefs", Context.MODE_PRIVATE)
        donate.setOnClickListener({
            val editor = sharedPref.edit()
            val u = name.text.toString()
            val p = phn.text.toString()
            editor.putString("username",u)
            editor.putString("phn",p)
            editor.apply()
                    })
    }

val sharedPref = getSharedPreferences("userPrefs", Context.MODE_PRIVATE)
        val name = sharedPref.getString("username", "GUEST")
        val phn = sharedPref.getString("phn", "NOT FOUND")


Status Notification:
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
private val CHANNEL_ID = "simple"
private val NOTIFICATION_ID = 2324
 val nbtn = findViewById<Button>(R.id.notifybtn)
        createNotification()
        nbtn.setOnClickListener{
            sendNotification()
        }
private fun createNotification(){
        if(Build.VERSION.SDK_INT>Build.VERSION_CODES.O){
            val channel = NotificationChannel(
                CHANNEL_ID,
                "simple_channel",
                NotificationManager.IMPORTANCE_DEFAULT
            )
            val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            manager.createNotificationChannel(channel)
        }
    }
    private fun sendNotification(){
        val notification = NotificationCompat.Builder(this,CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .setContentTitle("Sample Notification")
            .setContentText("This is a sample Notification")
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .build()
        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        manager.notify(NOTIFICATION_ID,notification)
    }


Dialogues(Date,Time,Progressbar)
Date and Time:
val cal = Calendar.getInstance()

        dbtn.setOnClickListener {
            val year = cal.get(Calendar.YEAR)
            val month = cal.get(Calendar.MONTH)
            val day = cal.get(Calendar.DAY_OF_MONTH)
            DatePickerDialog(this, { _, y, m, d ->
                dtxt.text = "$d/${m+1}/$y"
            }, year, month, day).show()
        }

        tbtn.setOnClickListener {
            val hour = cal.get(Calendar.HOUR_OF_DAY)
            val min = cal.get(Calendar.MINUTE)
            TimePickerDialog(this, { _, h, m ->
                ttxt.text = "$h:$m"
            }, hour, min, true).show()
        }

Progressbar:
 progress.progress = 0
Thread {
                for (i in 1..100) {
                    Thread.sleep(30)
                    runOnUiThread {
                        progress.progress = i
                    }
                }.start()

AlertDialog

override fun onBackPressed() {
        super.onBackPressed()
        val builder = AlertDialog.Builder(this)
        with(builder){
            setTitle("Exit app")
            setMessage("Are you sure you want to exit?")
            setPositiveButton("Yes"){_,_ ->finishAffinity()}
            setNegativeButton("No",null)
            setCancelable(true)
            show()
        }
    }

Geocoder:
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
    <uses-permission android:name="android.permission.INTERNET"/>
val la = lat.text.toString().toDoubleOrNull()
val lo = lon.text.toString().toDoubleOrNull()
val geocoder = Geocoder(this, Locale.getDefault())
                try {
                    val addresses = geocoder.getFromLocation(la, lo, 1)
                        if (addresses != null && addresses.isNotEmpty()) {
                            val address = addresses[0].getAddressLine(0)
                            result.text = "Address : $address"
                        } else {
                            Toast.makeText(this, "No address found for this location", Toast.LENGTH_SHORT).show()
                        }
                    }
                } catch (e: Exception) {
                        Toast.makeText(this, "Error occurred in fetching address: ${e.message}", Toast.LENGTH_SHORT).show()
                    }