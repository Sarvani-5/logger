SQLLITE:

private lateinit var adapter: ArrayAdapter<String>
    private lateinit var dbHelper: EventDatabaseHelper
 dbHelper = EventDatabaseHelper(this)

        nameEditText = findViewById(R.id.editTextName)
        locationEditText = findViewById(R.id.editTextLocation)
        addButton = findViewById(R.id.buttonAdd)
        eventsListView = findViewById(R.id.listViewEvents)
        adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, ArrayList<String>())
        eventsListView.adapter = adapter
        loadEvents()

        addButton.setOnClickListener {
            addEvent()
        }

        eventsListView.setOnItemLongClickListener { _, _, position, _ ->
            val eventString = adapter.getItem(position) ?: return@setOnItemLongClickListener false
            val id = eventString.split(" - ")[0].toInt()
            deleteEvent(id)
            true
        }
    }

    private fun addEvent() {
        val name = nameEditText.text.toString().trim()
        val location = locationEditText.text.toString().trim()

        if (name.isEmpty() || location.isEmpty()) {
            Toast.makeText(this, "Please fill all fields", Toast.LENGTH_SHORT).show()
            return
        }

        val id = dbHelper.addEvent(name, location)

        if (id != -1L) {
            nameEditText.text.clear()
            locationEditText.text.clear()

            loadEvents()

            Toast.makeText(this, "Event added successfully", Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(this, "Failed to add event", Toast.LENGTH_SHORT).show()
        }
    }

    private fun deleteEvent(id: Int) {
        val deleted = dbHelper.deleteEvent(id)

        if (deleted > 0) {
            loadEvents()
            Toast.makeText(this, "Event deleted", Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(this, "Failed to delete event", Toast.LENGTH_SHORT).show()
        }
    }

    private fun loadEvents() {
        adapter.clear()

        val eventsList = dbHelper.getAllEvents()

        for (event in eventsList) {
            adapter.add("${event.id} - ${event.name} - ${event.location}")
        }

        adapter.notifyDataSetChanged()
    }
}

data class Event(val id: Int, val name: String, val location: String)

class EventDatabaseHelper(context: Context) :
    SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {

    companion object {
        private const val DATABASE_NAME = "events.db"
        private const val DATABASE_VERSION = 1
        private const val TABLE_EVENTS = "events"
        private const val COLUMN_ID = "id"
        private const val COLUMN_NAME = "name"
        private const val COLUMN_LOCATION = "location"
    }

    override fun onCreate(db: SQLiteDatabase) {
        val createTableSQL = """
            CREATE TABLE $TABLE_EVENTS (
                $COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,
                $COLUMN_NAME TEXT NOT NULL,
                $COLUMN_LOCATION TEXT NOT NULL
            )
        """.trimIndent()

        db.execSQL(createTableSQL)
    }

    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        db.execSQL("DROP TABLE IF EXISTS $TABLE_EVENTS")
        onCreate(db)
    }

    fun addEvent(name: String, location: String): Long {
        val db = this.writableDatabase
        val values = ContentValues().apply {
            put(COLUMN_NAME, name)
            put(COLUMN_LOCATION, location)
        }

        val id = db.insert(TABLE_EVENTS, null, values)
        db.close()
        return id
    }

    fun deleteEvent(id: Int): Int {
        val db = this.writableDatabase
        val result = db.delete(TABLE_EVENTS, "$COLUMN_ID = ?", arrayOf(id.toString()))
        db.close()
        return result
    }

    fun getAllEvents(): List<Event> {
        val eventsList = ArrayList<Event>()
        val db = this.readableDatabase
        val query = "SELECT * FROM $TABLE_EVENTS"
        val cursor = db.rawQuery(query, null)

        if (cursor.moveToFirst()) {
            do {
                val id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ID))
                val name = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NAME))
                val location = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_LOCATION))

                val event = Event(id, name, location)
                eventsList.add(event)
            } while (cursor.moveToNext())
        }

        cursor.close()
        db.close()
        return eventsList
    }


Firebase:

id("com.google.gms.google-services") version "4.4.2" apply false
id("com.google.gms.google-services")
implementation(platform("com.google.firebase:firebase-bom:33.13.0"))

import com.google.firebase.firestore.FirebaseFirestore
private lateinit var db: FirebaseFirestore

val contact = hashMapOf(
            "id" to id,
            "name" to name,
            "phoneNumber" to phoneNumber
        )
        db.collection("contacts")
            .document(id)
            .set(contact)
            .addOnSuccessListener {
                Toast.makeText(this, "Contact saved successfully with ID: $id", Toast.LENGTH_SHORT).show()
                loadContacts()
            }
            .addOnFailureListener { e ->
                Toast.makeText(this, "Error saving contact: ${e.message}", Toast.LENGTH_SHORT).show()
            }

private fun loadContacts() {
        contactsTextView.text = "Loading contacts..."
        db.collection("contacts")
            .get()
            .addOnSuccessListener { result ->
                val stringBuilder = StringBuilder()
                if (result.isEmpty) {
                    stringBuilder.append("No contacts found.")
                } else {
                    for (document in result) {
                        val id = document.getString("id") ?: document.id
                        val name = document.getString("name") ?: "Unknown"
                        val phone = document.getString("phoneNumber") ?: "No number"
                        stringBuilder.append("ID: $id\nName: $name\nPhone: $phone\n\n")
                    }
                }
                contactsTextView.text = stringBuilder.toString()
            }
            .addOnFailureListener { e ->
                contactsTextView.text = "Error loading contacts: ${e.message}"
            }
    }

private fun deleteContact() {
        val idToDelete = deleteIdEditText.text.toString().trim()
        db.collection("contacts")
            .document(idToDelete)
            .delete()
            .addOnSuccessListener {
                Toast.makeText(this, "Contact with ID: $idToDelete deleted successfully", Toast.LENGTH_SHORT).show()
                deleteIdEditText.text.clear()
                loadContacts()
            }
            .addOnFailureListener { e ->
                Toast.makeText(this, "Error deleting contact: ${e.message}", Toast.LENGTH_SHORT).show()
            }


private fun findContactById() {
        val idToFind = updateIdEditText.text.toString().trim()
        db.collection("contacts")
            .document(idToFind)
            .get()
            .addOnSuccessListener { document ->
                if (document != null && document.exists()) {
                    val name = document.getString("name") ?: ""
                    val phone = document.getString("phoneNumber") ?: ""
                    updateNameEditText.setText(name)
                    updatePhoneEditText.setText(phone)
                    Toast.makeText(this, "Contact found", Toast.LENGTH_SHORT).show()
                } else {
                    Toast.makeText(this, "No contact found with ID: $idToFind", Toast.LENGTH_SHORT).show()
                    updateNameEditText.text.clear()
                    updatePhoneEditText.text.clear()
                }
            }
            .addOnFailureListener { e ->
                Toast.makeText(this, "Error finding contact: ${e.message}", Toast.LENGTH_SHORT).show()
            }
    }


val updatedContact = hashMapOf(
            "id" to idToUpdate,
            "name" to updatedName,
            "phoneNumber" to updatedPhone
        )
        db.collection("contacts")
            .document(idToUpdate)
            .set(updatedContact)
            .addOnSuccessListener {
                Toast.makeText(this, "Contact updated successfully", Toast.LENGTH_SHORT).show()
                updateIdEditText.text.clear()
                updateNameEditText.text.clear()
                updatePhoneEditText.text.clear()
                loadContacts()
            }
            .addOnFailureListener { e ->
                Toast.makeText(this, "Error updating contact: ${e.message}", Toast.LENGTH_SHORT).show()
            }

